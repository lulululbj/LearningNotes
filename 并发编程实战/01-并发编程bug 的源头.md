核心矛盾： CPU、内存、I/O 设备的速度差异。

1. CPU 增加了缓存，以均衡与内存的速度差异
2. 操作系统增加了线程、进程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异
3. 编译程序优化指令执行顺序，使得缓存能够得到更加合理的利用

## 缓存导致的可见性问题

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为 **可见性** 。

多核时代，CPU 缓存与内存的数据一致性无法保证。

## 线程切换带来的原子性问题

操作系统做任务切换，可以发生在任何一条 **CPU 指令** 执行完。是 CPU 指令，而不是高级语言的一条语句。

我们把一个操作或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符。

## 编译优化带来的有序性问题

编译器为了优化性能，有时候会改变程序中语句的先后顺序。

DCL 问题。


```java
public class DCLSingleton {

    private static DCLSingleton mInstance;

    private DCLSingleton() {
    }

    public static DCLSingleton getInstance() {
        if (mInstance == null) {                    // 1
            synchronized (DCLSingleton.class) {     // 2
                if (mInstance == null)              // 3
                    mInstance = new DCLSingleton(); // 4
            }
        }
        return mInstance;
    }
}
```

`1` 处做第一次判断，如果已经实例化了，直接返回对象，避免无用的同步消耗。`2` 处仅对实例化过程做同步操作，保证单例。`3` 处做第二次判断，只有 `mInstance` 为空时再初始化。看起来时多么的完美，保证线程安全的同时又兼顾性能。但是 DCL 存在一个致命缺陷，就是重排序导致的多线程访问可能获得一个未初始化的对象。

首先记住上面标记的 4 行代码。其中第 4 行代码 `mInstance = new DCLSingleton();` 在 JVM 看来有这么几步：

> 1. 为对象分配内存空间
> 2. 初始化对象
> 3. 将 mInstance 引用指向第 1 步中分配的内存地址

在单线程内，在不影响执行结果的前提下，可能存在指令重排序。例如下列代码：

```java
int a = 1;
int b = 2;
```

在 JVM 中你是无法确保这两行代码谁先执行的，因为谁先执行都不影响程序运行结果。同理，创建实例对象的三部中，第 2 步 **初始化对象** 和 第 3 步 **将 mInstance 引用指向对象的内存地址** 之间也是可能存在重排序的。

> 1. 为对象分配内存空间
> 2. 将 mInstance 引用指向第 1 步中分配的内存地址
> 3. 初始化对象

这样的话，就存在这样一种可能。线程 A 按上面重排序之后的指令执行，当执行到第 2 行 **将 mInstance 引用指向对象的内存地址** 时，线程 B 开始执行了，此时线程 A 已为 `mInstance` 赋值，线程 B 进行 DCL 的第一次判断 `if (mInstance == null)` ,结果为 `false`，直接返回 `mInstance` 指向的对象，但是由于重排序的缘故，对象其实尚未初始化，这样就出问题了。还挺绕口的，借用 《Java 并发编程艺术》 中的一张表格，会对执行流程更加清晰。

| 时间  | 线程 A | 线程 B |
| :---: |---|---|
|  t1 |  A1: 分配对象的内存空间  |     |
|  t2 |  A3: 设置 mInstance 指向内存空间  |     |
|  t3 |    |  B1: 判断 mInstance 是否为空   |
|  t4 |    |  B2: 由于 mInstance 不为空，线程 B 将访问 mInstance 指向的对象   |
|  t5 |  A2: 初始化对象  |     |
|  t6 |  A3: 访问 mInstance 引用的对象  |     |

`A3` 和 `A2` 发生重排序导致线程 B 获取了一个尚未初始化的对象。

说了半天，该怎么改？其实很简单，禁止多线程下的重排序就可以了，只需要用 `volatile` 关键字修饰 `mInstance` 。在 JDK 1.5 中，增强了 volatile 的内存语义，对一个volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。volatile 会禁止一些处理器重排序，此时 DCL 就做到了真正的线程安全。